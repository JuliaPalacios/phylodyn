---
title: "Distances between ranked tree shapes example for n=5"
author: "Jaehee Kim"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Distance example}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This vignette demonstrates generation of F-matrices and a distance matrix between ranked tree shapes with $n=5$. a simple example  

We first load all five ranked tree shapes for $n=5$.
```{r, include=TRUE, message=FALSE, warning=FALSE}
library(phylodyn)
data(tr_list)
```

```{r, include=TRUE, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.width=6, fig.height=4}
par(mfrow=c(2,3), mar=c(1,1,1,1), cex=1)
for (i in 1:length(tr_list)) {
    ape::plot.phylo(ape::ladderize(tr_list[[i]]),
                    directio='downward', main=paste('Tree', i),
                    edge.width=2)
}
```

We now generate F-matrix for each ranked tree shape.
```{r, include=TRUE, message=FALSE, warning=FALSE}
Fmat_list <- list()
for (i in 1:length(tr_list)) {
    Fmat_list[[i]] <- gen_Fmat(tr_list[[i]])
}
print(Fmat_list)
```

We next compute pairwise distances between above five ranked tree shapes for $n=5$. In this example, we use $L_1$ distance and considers ranked tree shapes only (i.e., unweighted).
```{r, include=TRUE, message=FALSE, warning=FALSE}
dmat <- matrix(0, nrow=length(tr_list), ncol=length(tr_list))
for (i in 1:length(tr_list)) {
    for (j in 1:i) {
        dmat[i,j] <- dist_pairwise(tr_list[[i]], tr_list[[j]], dist.method="l1", weighted=FALSE)
    }
}
tmp <- dmat[lower.tri(dmat)]
dmat <- t(dmat)
dmat[lower.tri(dmat)] <- tmp
print(dmat) 
```

We can visualize the MDS of those 5 trees:

```{r, include=TRUE, message=FALSE, warning=FALSE}
mds <- cmdscale(dmat, eig=T, k=2)
plot(mds$points[,1:2])  
```    

We also compute the distances with adaptations of other tree distances to ranked tree shapes.
To adapt other metrics, we assign unique labels to leaves:

```{r, include=TRUE, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center', fig.width=6, fig.height=4}
par(mfrow=c(2,3), mar=c(1,1,1,1), cex=1, xpd=T)
for (i in 1:length(tr_list_lab)) {
    ape::plot.phylo(ape::ladderize(tr_list_lab[[i]]), show.tip.label=F, direction='downward')
    ape::tiplabels(cex=1.2, frame='none', offset=0.2)
}
```



```{r, include=TRUE, message=FALSE, warning=FALSE}
n_tr <- length(tr_list)

# ==== d1 ==== 
d1.dmat <- matrix(0, nrow=n_tr, ncol=n_tr)
for (i in 1:n_tr) {
    for (j in 1:n_tr) {
        d1.dmat[i,j] <- dist_pairwise(tr_list[[i]], tr_list[[j]],
                                      dist.method="l1", weighted=FALSE)
    }
}
knitr::kable(round(d1.dmat, 2), caption='d_1')


# ==== d2 ==== 
d2.dmat <- matrix(0, nrow=n_tr, ncol=n_tr)
for (i in 1:n_tr) {
    for (j in 1:n_tr) {
        d2.dmat[i,j] <- dist_pairwise(tr_list[[i]], tr_list[[j]],
                                      dist.method="l2", weighted=FALSE)
    }
}

knitr::kable(round(d2.dmat, 2), caption='d_2')

# ==== d_{CP-RTS} ==== 
cp.dmat <- matrix(0, nrow=n_tr, ncol=n_tr)

tmp <- treetop::vecMultiDistUnlab(tr_list)
cp.dmat[lower.tri(cp.dmat)] <- tmp
cp.dmat <- t(cp.dmat)
cp.dmat[lower.tri(cp.dmat)] <- tmp

knitr::kable(round(cp.dmat, 2), caption='d_{CP-RTS}')


# ==== d_{RF-RTS} ==== 
rf.dmat <- matrix(0, nrow=n_tr, ncol=n_tr)

tmp <- phangorn::RF.dist(tr_list_lab, normalize=FALSE, 
                         check.labels=TRUE,
                         rooted=TRUE)
rf.dmat[lower.tri(rf.dmat)] <- tmp
rf.dmat <- t(rf.dmat)
rf.dmat[lower.tri(rf.dmat)] <- tmp

knitr::kable(round(rf.dmat, 2), caption='d_{RF-RTS}')


# ==== d_{KC-RTS} ==== 
kc1.dmat <- matrix(0, nrow=n_tr, ncol=n_tr)

tmp <- treespace::multiDist(tr_list_lab, lambda=0)
kc1.dmat[lower.tri(kc1.dmat)] <- tmp
kc1.dmat <- t(kc1.dmat)
kc1.dmat[lower.tri(kc1.dmat)] <- tmp

knitr::kable(round(kc1.dmat, 2), caption='d_{KC-RTS}')


# ==========================
#       kc2 (KC-RTS')
# ==========================
# need to make sure that we relable the tips and internal nodes
kc2.dmat <- matrix(0, nrow=n_tr, ncol=n_tr)

tmp <- treespace::multiDist(tr_list_lab, lambda=0.5)
kc2.dmat[lower.tri(kc2.dmat)] <- tmp
kc2.dmat <- t(kc2.dmat)
kc2.dmat[lower.tri(kc2.dmat)] <- tmp

print("kc2")
knitr::kable(round(kc2.dmat, 2), caption='d_{KC-RTS*}')



# ==== d_{BHV-RTS} ==== 
bhv.dmat <- matrix(0, nrow=n_tr, ncol=n_tr)

tmp <- distory::dist.multiPhylo(tr_list_lab)
bhv.dmat[lower.tri(bhv.dmat)] <- tmp
bhv.dmat <- t(bhv.dmat)
bhv.dmat[lower.tri(bhv.dmat)] <- tmp

knitr::kable(round(bhv.dmat, 2), caption='d_{BHV-RTS}')


# ==== d_{BHV-RTS*} ==== 
bhv2.dmat <- matrix(0, nrow=n_tr, ncol=n_tr)
lab.perm <- combinat::permn(1:n_tr)

tmp.vec <- rep(NA, 10)
counter.vec <- 0

for (i in 1:n_tr) {
    for (j in 1:n_tr) {
        print(c(i,j))
        if (i < j) {
            tr.1 <- tr_list_lab[[i]]
            tr.2 <- tr_list_lab[[j]]
            
            tr.edge.1 <- tr.1$edge
            tr.edge.2 <- tr.2$edge
            tip.ind.1 <- which(tr.1$edge[,2] < 6)
            tip.ind.2 <- which(tr.2$edge[,2] < 6)
            
            tmp.list.1 <- list()
            tmp.list.2 <- list()
            for (k in 1:length(lab.perm)) {
                tr.edge.1[tip.ind.1, 2] <- lab.perm[[k]]
                tr.edge.2[tip.ind.2, 2] <- lab.perm[[k]]
                
                tr.1$edge <- tr.edge.1
                tr.2$edge <- tr.edge.2
                
                tmp.list.1[[k]] <- tr.1
                tmp.list.2[[k]] <- tr.2
            }
            
            tmp.dist <- rep(NA, length(lab.perm)*length(lab.perm))
            counter <- 0
            for (ind.1 in 1:length(lab.perm)) {
                for (ind.2 in 1:length(lab.perm)) {
                    counter <- counter + 1
                    tmp.dist[counter] <- c(distory::dist.multiPhylo(list(tmp.list.1[[ind.1]], tmp.list.2[[ind.2]])))
                }
            }
            counter.vec <- counter.vec + 1
            tmp.vec[counter.vec] <- min(tmp.dist)
        }
    }
}

bhv2.dmat[lower.tri(bhv2.dmat)] <- tmp.vec
bhv2.dmat <- t(bhv2.dmat)
bhv2.dmat[lower.tri(bhv2.dmat)] <- tmp.vec

knitr::kable(round(bhv2.dmat, 2), caption='d_{BHV-RTS*}')



```


We now simulate 10 trees with n=50 tips from 5 different Beta-splitting distributions. The random trees are generated using the code by Maliet 2018. We compute the pairwaise L1 distance matrix of 50 by 50 and plot the MDS of the distance matrix:

```{r, include=TRUE, message=FALSE, warning=FALSE}
sim.tag <- T
rand.seed <- 1
treetypes <- c("balanced", "yule", "ab", "pda", "unbalanced")
n.sim <- 10 # number of simulations
n.tip <- 50 # number of tips
n.model <- length(treetypes)
set.seed(rand.seed)
n.model <- length(treetypes)
Fmat.list <- list()
tr.list <- list()
for (i in 1:length(treetypes)) {
  t.mode <- treetypes[i]
  print(t.mode)
  alpha <- 1
  eta <- 1
  epsilon <- 0.001 # the same value used in Maliet, Gascuel, and Lambert (2018)
        if (t.mode == 'balanced') {
            beta <- 100
        } else if (t.mode == 'yule') {
            beta <- 0
        } else if (t.mode == 'ab') {
            beta <- -1
        } else if (t.mode == 'pda') {
            beta <- -1.5
        } else if (t.mode == 'unbalanced') {
            beta <- -1.9
        }


        tr.list[[i]] <- list()
        Fmat.list[[i]] <-list()
        for (j  in 1:n.sim) {
            tmp.tr <- apTreeshape::simulate_tree(epsilon=epsilon, alpha=alpha, beta=beta, N=n.tip)
            tr.list[[i]][[j]] <- tmp.tr
            Fmat.list[[i]][[j]] <- gen_Fmat(tmp.tr)
        }
}

names(tr.list) <- treetypes
names(Fmat.list) <- treetypes

all.Fmat <- unlist(Fmat.list, recursive=FALSE)
all.tr <- unlist(tr.list, recursive=FALSE)
dmat.L1 <- matrix(0, nrow=length(all.tr), ncol=length(all.tr))

for (i in 2:length(all.tr)) {
    for (j in 1:(i-1)) {
        print(c(i,j))
        dmat.L1[i,j] <- dist_pairwise(all.tr[[i]], all.tr[[j]],
                                      dist.method="l1", weighted=FALSE)
    }
}

tmp <- c(dmat.L1[lower.tri(dmat.L1)])
dmat.L1 <- t(dmat.L1)
dmat.L1[lower.tri(dmat.L1)] <- tmp

mds <- cmdscale(dmat.L1, eig=T, k=3)
mds.pts.l1 <- mds$points[,1:2]

## Find medoid points for each model and plot
find.medoid <- function(dmat) {
    total.dist <- apply(dmat, 1, sum)
    return(which(total.dist == min(total.dist)))
}
addalpha <- function(colors, alpha=1.0) {
    r <- col2rgb(colors, alpha=T)
    # Apply alpha
    r[4,] <- alpha*255
    r <- r/255.0
    return(rgb(r[1,], r[2,], r[3,], r[4,]))
}

m.pts <- list()
for (i in 1:n.model) {
    tr.ind <- ((i-1)*n.sim + 1):(i*n.sim)
    m.pts[[i]] <- find.medoid(dmat.L1[tr.ind, tr.ind]) + (i-1)*n.sim
}

col.set <- 'Dark2'
col.vec <- RColorBrewer::brewer.pal(n.model, col.set)
col.vec[1] <- "#E6AB02"
cols <- addalpha(col.vec, 0.25)
cols.sol <- addalpha(col.vec, 1.0)

plt.xlim <- c(min(mds.pts.l1[,1]), max(mds.pts.l1[,1]))
plt.ylim <- c(min(mds.pts.l1[,2]), max(mds.pts.l1[,2]))


par(mfrow=c(1,1), pty="s", mar=c(4,4,2,2), cex=1.5, xpd=T)
plot(mds.pts.l1[1:n.sim,], 
     col=cols[1], pch=16, cex=1, xaxt='n', yaxt='n',
     xlab='', ylab='', xlim=plt.xlim, ylim=plt.ylim)
for (i in 2:n.model) {
    plt.ind <- ((i-1)*n.sim + 1):(i*n.sim)
    points(mds.pts.l1[plt.ind, ], col=cols[i], pch=16, cex=1)
}

# plot medoid points
for (i in 1:n.model) {
    points(mds.pts.l1[m.pts[[i]], 1], mds.pts.l1[m.pts[[i]], 2],
           bg=cols.sol[i], pch=24, 
           cex=1.5, col="black", lwd = 2)
}

legend("right", legend = treetypes,
       inset=c(-0.7, 0),
       col=cols.sol, bty='n',
       pch=17, cex=1, pt.cex=1)

## First 10 Eigenvalues and Goodness of Fit
par(mfrow=c(1,2), pty="s", mar=c(4,4,2,2), cex=1.5)
plot(mds$eig[1:10]/sum(mds$eig), type="h", lwd=3, las=1, col='blue',
     xlab="Number of dimensions", ylab="Eigenvalues")
plot(mds$eig/sum(mds$eig), type="l", lwd=3, las=1, col='blue',
     xlab="Number of dimensions", ylab="Eigenvalues")
print(mds$GOF)

## Number of negative eigenvalues
neg.eig.ind <- which(mds$eig < 0)
neg.eig <- mds$eig[neg.eig.ind]
print(paste('number of negative eigenvalues:', length(neg.eig.ind),
            'of', length(mds$eig)))
print(paste('(scaled) max', max(neg.eig)/sum(mds$eig),
            'and (scaled) min', min(neg.eig)/sum(mds$eig)))

## Plot medoid trees.
par(mfrow=c(2,3), oma=c(1,1,1,1), mar=c(2,2,2,2), cex=1.5)
for(i in 1:n.model) {
    m.tr.ind <- m.pts[[i]][1] - (i-1)*n.sim
    plot.phylo(ape::ladderize(tr.list[[i]][[m.tr.ind]]), show.tip.label=F,
               main=paste('model =', treetypes[i]))
}
mtext("Medoid Tree", side=3, line=-21.5, outer=T, font=2, cex=2)


    

```


This is an example of heterochronously sampled genealogies. We first simulate... We use our weighted L2 distance... We plot the MDS... We observe that... . The Frechet mean is calculated as follows... The uncertainty measure is...





